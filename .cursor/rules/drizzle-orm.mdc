---
description: Drizzle: Essential patterns for secure DB ops & transactions
globs: 
alwaysApply: false
---
# Drizzle ORM Guide

> Follow these guidelines whenever you read or write data. They are enforced by code-review and automated tests.

## Core Files
* [src/server/db/index.ts](mdc:src/server/db/index.ts) â€“ initialises and exports the typed Drizzle client `db`.
* [src/server/db/schema.ts](mdc:src/server/db/schema.ts) â€“ table definitions used across the codebase (`ideasTable`, `waitlistTable`, â€¦).
* [src/server/db/queries](mdc:src/server/db/queries) â€“ **the only place** where SQL queries are written. Components & route handlers must import helpers from this folder, never the raw `db` client.
* [drizzle.config.ts](mdc:drizzle.config.ts) â€“ CLI configuration that points Drizzle Kit at the correct database.

## Useful npm Scripts (from `package.json`)
```
# generate & run migrations locally
npm run db:generate   # create new migration files
npm run db:migrate    # apply pending migrations

# misc helpers
npm run db:push       # push current schema (CI only â€“ **developers must NOT run this**)  
npm run db:studio     # open the Drizzle Studio GUI
```

### ðŸš¨ Migration Safety Rule
Developers may modify the schema and run `npm run db:generate`, but **must never execute `db:push` or manual SQL against shared environments**. Migrations are applied automatically by the CI/CD pipeline.

---

## Schema Example (current codebase)
```typescript
// src/server/db/schema.ts
export const ideasTable = pgTable('ideas', {
  id: serial('id').primaryKey(),
  text: text('text').notNull(),
  created_at: timestamp('created_at').notNull().defaultNow(),
});
```

## Query Example
```typescript
// src/server/db/queries/ideas.ts
export async function listIdeas(): Promise<SelectIdea[]> {
  return db.select().from(ideasTable).orderBy(desc(ideasTable.created_at));
}
```

## Loader / Action Usage
```typescript
// src/server/ideas.ts
import { IdeaSchema } from "@shared/schema";
import { createIdea, listIdeas } from "@server/db/queries/ideas";

export async function loader() {
  const ideas = await listIdeas();
  return new Response(JSON.stringify({ success: true, ideas }), {
    headers: { 'Content-Type': 'application/json' },
  });
}

export async function action({ request }: Route.ActionArgs) {
  const data = IdeaSchema.parse(await request.json());
  const created = await createIdea({ text: data.text });
  return new Response(JSON.stringify({ success: true, idea: created }), {
    headers: { 'Content-Type': 'application/json' },
  });
}
```

## File-Upload + Transaction Pattern
```typescript
// Simplified pattern for atomic upload + record creation
await db.transaction(async (tx) => {
  const [idea] = await tx.insert(ideasTable).values({ text }).returning();
  try {
    const { url } = await uploadFile(file);
    await tx.update(ideasTable).set({ image_url: url }).where(eq(ideasTable.id, idea.id));
  } catch (err) {
    // the transaction is rolled-back automatically
    await cleanupFile();
    throw err;
  }
});
```

## Golden Rules
1. **Filter by user scope** whenever a `user_id` column exists.
2. **Never** access the raw `db` client outside of `src/server/db/queries/*`.
3. **Always** wrap database calls in `try/catch` and return typed responses.
4. **Use transactions** for multi-step writes (eg. upload + DB insert).
5. **Let CI apply migrations** â€“ local `db:generate` is okay, `db:push` is prohibited.

